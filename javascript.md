# 犀牛书学习笔记

[TOC]

## 一、基础知识
> JavaScript简介
> 是Web编程语言，是一门高级、动态、解释型编程语言，适合面向对象和函数式编程风格。语法与Java大致相仿，但除此两者无任何关系。浏览器是其最早的宿主环境，2010年后，出现另一宿主环境Node，可以访问整个操作系统的权限。

### 1. 词法结构（一门语言最低级的语法）
注释：单行// 与 多行/* */
字面量：一种**直接**出现在程序中的数据值。
标识符：即名字，命名常量、变量、属性、函数、类。必须以字母、下划线或美元符号开头。
保留字：不能用作标识符。
Unicode：JavaScript**程序**是用Unicode字符集编写的。故在字符串和注释中可使用任意Unicode字符，建议标识符只用ASCII字母和数字。转义序列（**\u后跟4位十六进制数字**）可令ASCII字符来表示Unicode字符，在注释中会被忽略。注意Unicode归一化。

### 2. 类型、值和变量
* 原始类型： 数值、（文本）字符串、布尔（真）值、**null、undefined**、Symbol（符号）；6
* 对象类型：数组、Set、Map、Date、Error、函数、类等
>任何不是原始类型的值都是对象，对象（对象类型的成员）是属性的集合。对象类型可以修改（mutable），但原始类型不可以修改（immutable），理解字符串不可修改。
>

1. 数值 Number
	* 可用下划线将数值字面量分隔为容易看清的数字段。
	```javascript
	let billion=1_000_000_000;
	let bytes=0x89_AB_CD_EF;
	let bits=0b0001_1101_0111;
	let fraction=0.123_456_789;
	```
	
	* Infinity和NaN：JavaScript预定义了全局常量Infinity和NaN应对正无穷和非数值，可通过Number对象的属性获得。**NaN与任何值比较都不相等**，判断方式：`x!=x`或`Number.isNaN(x)`；负零值与正零值相等（即使在`use strict`下）。
   * 二进制浮点数与舍入错误
	* BigInt：ES2020，定义了一种新的数值类型：BigInt，为表示64位整数，表示：一串数字后面跟‘n’；算术运算不同在于*除法会丢弃余数并向下舍入*；+、-、*、/、**不能混用BigInt操作数和常规数值操作数，比较操作数允许混用，Math对象不接收BigInt操作数。
	
2. 文本 String

   * 字符串是16位值的不可修改的有序序列。
   * 代理对surrogate pair：码点超出16位的Unicode字符使用UTF-16规则编码为两个16位值的序列。
   * 使用反引号定界字符串是【ES6】的特性。
   * 字符串属性：length。
   * JavaScript中的**字符串是不可修改的**，像`replace()`和`toUpperCase()`这样的方法都返回新字符串。
   * 标签化模板字面量
   * 【ES6】提供内置的标签函数`String.raw()`，不会处理任何反斜杠转义。
   * 正则表达式（RegExp）数据类型用于描述和匹配文本中的字符串模式。

3. 布尔值

   * JavaScript的任何值都可以转换为布尔值，转为false：`undefined、null、0、-0、NaN、" "空字符串`，其他所有值都是true。
   * 布尔值只有`toString()`一个方法。

4. null与undefined

   * null通常表示某个值不存在，`typeof null结果是object`。
   * undefined表示变量未初始化、查询不存在的对象属性或数组元素、没有明确返回值的函数返回的值、没有传值的函数参数，它是一个预定义的全局变量。`typeof undefined结果是undefined`。
   * `null==undefined; //true   null===undefined; //false`
   * 他们是**唯一两个没有属性**的值。

5. 符号Symbol

   * 【ES6】新增的一种原始类型，用作非字符串的属性名。
   * 没有字面量语法。
   * `Symbol()`函数获取一个Symbol值，这个函数永远不会返回相同的值，即使每次传入参数一样，保证了唯一性。
   * 全局符号注册表。

6. 全局对象

   * 全局对象的属性是全局性定义的标识符，可以在JavaScript程序的任何地方使用。JavaScript解释器启动后（或每次浏览器加载新页面时），都会创建一个新的全局对象并为其添加一组初始的属性。
   * 在Node中，全局对象有一个名为global的属性。
   * 在浏览器中，**Windows对象对浏览器窗口中的所有JavaScript代码而言，充当了全局对象的角色**。这个全局对象有一个自引用的window属性，可以引用全局对象。
   * **ES2020**最终定义了**`globalThis`**作为在任何上下文中引用全局对象的标准方式。
   
7. 不可修改的原始值与可修改的对象引用

   * 原始类型不可修改，即没有办法改变原始值。
   * 对象有时被称为引用类型（reference type）。

8. 类型转换

   * 转换与相等

   * 显示转换

     * 最简单：`Boolean()、Number()、String()`

     * 除了null和undefined之外，所有值都有`toString()`方法。

     * `Boolean()、Number()、String()`也可以被当作构造函数通过new关键字来使用。

     * 某些JavaScript操作符会执行隐式类型转换。

     * Number类定义 的toString()方法会接收一个可选的参数，用于指定一个基数或底数，默认为10。

     * ```
       let n=123456.789;
       n.toFixed(0) //=>"123457"
       n.toFixed(2) //=>"123456.79"
       n.toExponential(1) //=>"1.2e+5"
       n.toExponential(3) //=>"1.235e+5"
       n.toPrecision(4) //=>"1.235e+5"
       n.toPrecision(7) //=>"123456.8"
       ```

     * `parseInt()`可以接收第二个参数值，用于指定要解析数值的底（基）数；  `parseFloat()`

   * 对象到原始值转换（搭配[对象 — 原始值转换 (javascript.info)](https://zh.javascript.info/object-toprimitive)理解较好）
   
     * JavaScript规范定义了对象到原始值转换的3种基本算法，偏字符串、偏数值、无偏好。
   
     * 算法在JavaScript中的用法：转换为布尔值无需使用上述算法，转换为字符串使用偏字符串，转换为数值用偏数值。
   
     * 存在不遵循上述基本的对象到字符串或数值转换规则的操作符转换特例。
   
     * toString()和valueOf方法：所有对象都会继承的在对象到原始值转换时使用的方法。
   
       ​	toString()返回对象的字符串表示，`({x:1,y:2}).toString() //=>"[object object]"`，很多类都定义了自己特有的toString()版本。
   
       ​	valueOf()方法：大体可认为它把对象转换为代表对象的原始值（若存在这样一个值）；‘对象是复合值，且多数对象不能真正通过一个原始值来表示，因此默认情况下**只返回对象本身，而非返回原始值**。
       
       | 算法         | 顺序                                                         |
       | ------------ | ------------------------------------------------------------ |
       | 偏字符串算法 | 先toString()再valueOf()                                      |
       | 偏数值算法   | 先valueOf()再toString()                                      |
       | 无偏好算法   | 取决被转换对象的类，若为Date则用偏字符串算法，其他用偏数值算法 |
   
9. 变量声明与赋值

   * 使用let和const声明
      * 【ES6】之后是通过let关键字声明的；若不为变量指定初始值，则默认undefined。
      * const必须在声明时初始化常量，常量的值是不能改变的，尝试给常量重新赋值会抛出**TypeError**；声明常量的一个常见约定是全部字母大写。
      * let和const声明的变量和常量具有块作用域。
      * JavaScript的**变量声明与值的类型无关**。
      
   * 使用var的变量声明
     * 【ES6】之前的JavaScript中，声明变量的唯一方式是使用var，无法声明常量。
     * 与let不同：
       * (1) 不具有块作用域，var的作用域是函数作用域。
       * (2) 若在函数体外部使用var，则会声明一个全局变量，并且实现为全局对象的属性。
       * (3) 多次声明是合法的。
       * (4) var有作用域提升的特性，即在var语句声明之前可以使用该变量。
     
   * 解构赋值【ES6】（destructuring assignment）
      * 数组解构
      
        * 解构让使用返回数组的函数变得敏捷；
      
        * 解构左侧变量的个数不一定与右侧数组中元素的个数相同，左侧多余的变量会被设为undefined，右侧多余的会被忽略，左侧的变量列表可以包含额外的逗号来跳过右侧的某些值。
      
          ```
          let [x,y]=[1]; //x==1; y==undefined
          [,x,,y]=[1,2,3,4]; //x==2; y==4
          ```
      
        * `let[x,...y]=[1,2,3,4]; //y=[2,3,4]`
      
        * 可以嵌套数组：`let [a,[b,c]]=[1,[2,2.5],3]; //a==1; b=2; c=2.5`
      
      * 对象解构
      
        * ````
          let transparent={r:0.0; g:0.0; b:0.0, a:1.0};
          let {r,g,b}=transparent; //r==0.0; g==0.0; b==0.0
          ````
      
        * 例子：将Math对象的全局函数复制到变量中，可简化需要大量三角计算的代码
      
          `const {sin,cos,tan}=Math;`**Math对象的属性远不止这3个，如果赋值左侧包含一个不是Math属性的变量名，该变量将被赋值undefined。**`const {cos:cosine,tan:tangent}=Math;`
      
      * 数组结构并**不要求必须是数组**，任何可迭代对象、任何可以在for/of循环中使用的对象也可以被解构
      
        `let [first,...rest]="Hello"; //first="H"; rest=["e","l","1","o"]`

### 3. 表达式和操作符（表达式是JavaScript程序中的短语）

1. 主表达式
   * 最简单的表达式称为主表达式，包括常量或字面量值、某些语言关键字和变量引用。
   * 当程序中出现任何独立的标识符时，JavaScript假设它时一个变量或常量或全局对象的属性，并查询它的值。如果不存在该名字的变量，则求值不存在的变量会导致抛出`ReferenceError`。
   
2. 对象和数组的初始化程序
   * 对象和数组初始化程序也是一种表达式，其值为新创建的对象或数组，有时被称为对象字面量和数组字面量。
   * `let sparseArray=[1,,,,5]`
   * 对象初始化程序表达式：`let p={x:1, y:2}`
   * 【ES6】后，对象字面量拥有更丰富的语法，可以嵌套。
   
3. 函数定义表达式
   * `let square=function(x){return x*x;};`记得最后有一个分号。
   
4. 属性访问表达式

   * 属性访问表达式求值为对象属性或数组元素的值，两种语法：`expression.identifier; expression[identifier]`

     第一种语法只用于**对象**。

5. 条件式属性访问

   * 【ES2020】新增两个新的属性访问表达式：`expression?.identifier; expression?.[expression]`，避免**如果.或[]左侧的表达式求值为null或undefined会报TypeError**的错误。
   * `a?.b`若a是null或者undefined则求值结果为undefined。
   * 这种形式有时也被称为“可选链接”。
   * 短路操作。

6. 调用表达式

   * 调用表达式是JavaScript中调用（或执行）函数或方法的一种语法。例子：

     ```
     f(0)
     Math.max(x,y,z)
     a.sort()
     ```

   * 求值调用表达式时，首先求值函数表达式，然后求值参数表达式以产生参数值的列表。

   * 如果函数使用了return语句返回一个值，则该值就成为调用表达式的值；否则值为undefined。

   * 如果该表达式是**属性访问表达式**，则这种调用被称为方法调用。在方法调用中，作为属性访问主体的对象或数组在执行函数体时会变成this关键字的值。

7. 条件式调用（联系条件式属性访问）

   * 【ES2020】中，可以使用`?.()`来调用函数，处理的问题跟条件式属性访问类似。

   * 短路操作：`let f=null,x=0;  f?.(x++) //x不会自增`

   * 区分一下：

     ```
     o.m()		//常规属性访问，常规调用
     o?.m()		//条件式属性访问，常规调用
     o.m?.()		//常规属性访问，条件式调用
     ```

8. 对象创建表达式

   * 对象创建表达式创建一个新对象并调用一个函数（称为构造函数）来初始化这个新对象。
   * `new Object(); new Point(2,3)`
   * 如果在对象创建表达式中不会给构造函数传参，则可以省略圆括号。`new Object; new Date`
   * 对象创造表达式的值时新创建的对象。

9. 操作符概述

   * 操作符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。

   * | 操作符 | 操作                     | 结合性 | 操作数个数 | 类型转换     |
     | ------ | ------------------------ | ------ | ---------- | ------------ |
     | ~      | 反转二进制位             | 右     | 1          | int~int      |
     | delete | 删除**属性**             | 右     | 1          | lval~bool    |
     | void   | 返回undefined            | 右     | 1          | any~undef    |
     | <<     | 左移位                   | 左     | 2          | int,int~int  |
     | >>     | 右移位以符号填充         | 左     | 2          | int,int~int  |
     | >>>    | 右移位以零填充           | 左     | 2          | int,int~int  |
     | in     | 测试**属性**是否存在     | 左     | 2          | any,obj~bool |
     | ??     | 选择第一个有定义的操作数 | 左     | 2          | any,any~any  |
     | ,      | 丢弃第一个，返回第二个   | 左     | 2          | any,any~any  |
	  
	* 注意有些操作符适用于任何类型的值，但多数操作符期待自己的操作数是某种特定类型。
	
	* JavaScript操作符通常会按照需要转换操作数的类型，`"3"*"5"`合法。
	
	* **lval**即lvalue（左值），历史悠久的术语，意思是“一个可以合法地出现在赋值表达式左侧的表达式”，在JavaScript中，**变量、对象属性和数组元素**都是“左值”。
	
	* 操作符副效应：有副效应的操作符—赋值操作符，递增和递减操作符，delete。
	
	* 操作符优先级：属性访问和调用表达式的优先级高于表4-1中列出的任何操作符。注意：`??  **`
	
	* JavaScript始终严格按照从左到右的顺序对表达式求值。
	
10. 算术表达式

    * 在JavaScript中，所有数值都是浮点数，因此所有除法操作数得到的都是浮点数。模操作数通常用于整数，但也可以用于浮点数。

    * +操作符

      ```
      1+2 //=>3
      "1"+"2" //=>"12"
      "1"+2 //=>"12"
      1+{} //=>"1[object Object]"
      true+true //=>2
      2+null //=>2
      2+undefined //=>NaN
      ```

    * 一元算术操作符

      * 一元操作符全部具有高优先级和右结合性。

    * 位操作符

11. 关系表达式

    * 关系表达式始终求值为布尔值，经常用于控制程序的执行流。

    * 对象是按引用而不是按值比较的，对象与自己相等，但与其他任何对象都不相等。

    * ===：如果一个或两个值是NaN，则不相等**（NaN不等于自身）**，检查某值是不是本身`x!==x或isNaN()`

    * ==：基于类型转换的相等。`null==undefined //=>true`

    * 比较操作符的操作数可能是任何类型，但比较只能针对数值和字符串，因此不是数值或字符串的操作数**会被转换类型**。如果转换或两个操作数都是字符串，则用字母表顺序比较（即组成字符串的**16位Unicode的数值顺序**）；若转换后至少一个不是字符串，则都被转换成数值来比较。

    * 如果有一个操作数是（或转换后是）NaN，那么这些比较操作符都返回false。

    * 更可靠的字符串比较算法可用String.localeCompare()方法，会考虑特定地区的字母表顺序。要执行不区分大小写的比较，可以使用String.toLowerCase()或String.toUpperCase()先转换成大写或小写再比较。

    * 比较操作符偏向于数值，+偏向于字符串。

    * in操作符：左侧操作数是**字符串、符号**或可以转换成字符串的值，右侧是**对象**；若左侧的值是右侧对象的属性名，则in返回true。

    * instanceof 操作符：左侧是**对象**，右侧是对象类的标识，返回true或false。

      `let d=new Date(); d instanceof Date`

      所有对象都是Object的实例，在确定对象是不是某个类的实例时会考虑超类，若左侧不是对象，则返回false，若右侧不是对象的类则抛出TypeError。理解其工作方式需要理解“原型链”。

12. 逻辑表达式

    * &&：有代码利用**这种行为**条件式地执行代码。`if(a===b)stop();与(a===b)&&stop();效果一样`
    * ||：习惯用法是在一系列备选项中选择第一个真值。`let max=maxWidth||preferences.maxWidth||500`，在【ES6】之前常用来在函数中给参数提供默认值，但【ES6】之后默认参数可以直接写在函数定义中。
    * !：要取得任何值x对应地布尔值，只要对x应用这个操作符两次即可。`!!x`

13. 赋值表达式

    * =具有右结合性。`i=j=k=0;`

14. 求值表达式

    * 全局函数eval()：JavaScript通过这个函数来对源代码字符串求值，`eval("3+2") //=>5`
    * 对源代码字符串的动态求值是一个强大的语言特性，但这种特性在实际项目中几乎用不到。eval()可能会成为安全漏洞，为此永远不要把来自用户输入的字符串交给它执行。
    * eval()期待一个参数，如果给它传入任何非字符串值，它会简单地返回这个值；如果传入字符串，他会尝试把这个字符串当成JavaScript代码来解析，解析失败会抛出SyntaxError；解析成功会求值代码并返回该字符串中最后一个表达式或语句的值；若最后一个表达式或语句没有值，则返回undefined。
    * use strict下的eval()

15. 其他操作符

    * ?:

    * ??：**先定义操作符**，只要左操作数不是null或undefined就返回左操作数。与||比较，可以处理0、空字符串、flase；??是在【ES2020】定义的，这个操作符的正式名字叫“缺值合并”（nullish coalescing）操作符。

    * typeof操作符：

      | x        | undefined   | null     | true/false | 数值或NaN | BigInt   | 字符串   | 符号     | 函数       | 非函数对象 |
      | -------- | ----------- | -------- | ---------- | --------- | -------- | -------- | -------- | ---------- | ---------- |
      | typeof x | "undefined" | "object" | "boolean"  | "number"  | "bigint" | "string" | "symbol" | "function" | "object"   |

    * delete操作符：尝试删除其操作数指定的对象属性或数组元素，并设置为undefined。

      * 注意：删除数组元素之后，数组长度没有变化；
      * 并非所有属性都是可以删除的：不可配置属性无法删除；
      * 在严格模式下，delete的操作数如果是未限定标识符，如变量、函数、函数参数，则会导致SyntaxError；严格模式下只能用作属性访问表达式。严格模式外不会发生异常，只是简单地返回false。

    * await操作符：【ES2017】增加的，用于让JavaScript中的异步编程更自然；await期待一个Promise对象作为唯一操作数，await只能出现在已经通过async关键字声明为异步的函数中。

    * void操作符：一元操作符，出现在操作数前面，操作数可以是任意类型。用处不多：求值自己的操作数，然后丢弃这个值并返回undefined。

    * 逗号操作符：会求值其左操作数，求值其右操作数，然后返回右操作数的值。

### 4. 语句

1. 表达式语句：有副效应的表达式。

2. 复合语句与空语句：语句块将多个语句组合为一个复合语句。

3. 条件语句：是 代码中需要决策的地方，故也被称为“分支”。规则：默认情况下else子句属于最近的if语句。

   ```
   switch(n){
   case 1: 
   	break;
   case 2:
   	break;
   default:
   	break;
   }
   ```

4. 循环语句：

   * 常见用途：迭代数组元素。语句会导致**“ 某些事情的发生 ”**。

   * do循环必须始终以分号终止。

   * for/of：【ES6】定义的新循环语句，专门用于可迭代对象，如数组、字符串、集合、映射，对象是不可迭代的。

     ```
     let data=[1,2,3,4,5],sum=0;
     for(let element of data){
     	sum+=element;
     }
     ```

     尝试对常规对象使用for/of会抛出TypeError，若想迭代对象的属性，可以使用for/in循环，或者基于Object.keys()方法的结果使用for/of：`for (let k of Obeject.keys(object)){}`，因为Object.keys()返回一个**对象属性名**的数组。还有Object.entries()方法，返回一个数组的数组，每个内部数组表示对象的一个属性的键/值对。

     注意：字符串是按照Unicode码点而不是UTF-16迭代的。

   * for/in：后面可以是任意**对象**，是JavaScript从一开始就有的。`for(variable in object)statement`，variable通常是一个变量名，但也可能是变量声明或任何可以作为赋值表达式左值的东西。variable可能是任何表达式，只要能求值为赋值表达式的左值就可以。如，把一个对象的所有属性赋值到数组中：

     ```
     let o={x:1,y:2,z:3};
     let a=[],i=0;
     for(a[i++] in 0); //空循环体
     ```

     JavaScript数组其实就是一种特殊的对象，数组的索引就是对象的属性，所以可以通过for/in来枚举。但是**操作数组时，基本上只会用到for/of而不是for/in**。

     for/in不会枚举对象的所有属性，如不会枚举名字为符号的属性，对于名字是字符串的属性，只会遍历枚举的属性，JavaScript核心定义的各种**内部方法**是不可枚举的。基于Object.keys()使用for/of循环可避免这问题。

5. 跳转语句

   * JavaScript允许给语句命名或加标签，这样break和continue就可以识别目标循环或其他语句的标签。

   * 语句标签：`identifier:statement`，任何语句都可以有标签，但是只有给那些有语句体的语句加标签才有意义。break和continue是JavaScript中唯一使用语句标签的语句。

   * break只有位于循环或switch语句中才合法，break与labelname之间不能出现换行符。

   * continue只能在循环体内使用，continue与labelname之间不能出现换行符。

   * return只能出现在函数体内，不能在return和它后面的表达式之间插入换行。

   * yield语句非常类似return，但只能用在【ES6】新增的生成器函数中，以回送生成的值序列中的下一个值，同时又不会真正返回。

   * throw语句，Error类只有一个name属性和一个message属性，分别用于指定错误类型和保存传入构造函数的字符串。

   * ```
     //模拟for(initiallize;test;increment)循环体
     initialize;
     while(test){
     try{body;}
     finally{increment;}
     }
     ```

   * with语句：`with(object) statement`，创建一个临时作用域，以object的属性作为变量，然后在这个作用域中执行statement，尽可能不使用它，严格模式下是被禁用的，非严格模式下也是被废弃了的。使用它主要是为了更方便地使用深度嵌套的对象。

     ```
     with(document.forms[0]){
     	name.value="";
     	address.value="";
     	email.value="";
     }
     ```

   * debugger语句：这个语句就像一个断点，执行中的JavaScript会停止。注意：debugger语句并不为你打开调试器。只有你使用浏览器并且打开了开发者控制台，这个语句才会导致断点。

   * `use strict`是【ES5】引入的一个指令，它与常规语句有两个重要区别：(1)指令是由（包含在单引号或双引号中的）特殊字符串字面量构成的表达式语句。(2)只能出现在脚本或函数体的开头，位于其他真正的语句之前。任何位于class体或P【ES6】模块中的代码全部默认为严格代码，无需显式写出"use strict"。

     * 严格模式是JavaScript的一个受限制的子集，这个子集修复了重要的语言缺陷，提供了更强的错误检查，也增强了安全性。

6. 声明

   * 关键字const, let, var, function, class, import, export严格来讲并不是语句，应该叫做声明。
   * 声明可以定义新值并给它们命名，以便将来通过这个名字引用相应的值；声明本身不会导致太多事情发生，但通过为值提供名字，他们会为程序中的其他语句定义相应的含义。
   * 可以把声明看成程序的一部分，这一部分会在代码运行前**预先处理**。
   * 无论在作用域中的什么地方声明函数，这些函数都会被提升。
   * 与函数不同，类声明不会被提升，所以在代码中不能在还没有声明类之前就使用类。
   * import和export：JavaScript模块中的值是私有的，除非被显式导出，否则其他模块都无法导入。如果一个模块只能导出一个值，通常会使用特殊的export default形式。`export default class Circle{ }`

### 5. 对象

1. 简介

   >对象是一个属性的无序集合，每个属性都有名字和值，属性名可以是任意字符串，包括空字符串（或任意符号）。JavaScript对象也可以从其他对象继承属性，这个其他对象称为其“原型”。

2. 创建对象

   >对象通过对象字面量、new关键字、Object.create()函数来创建。

   * 对象字面量：`let point={x:0,y:0};`记得末尾分号。

   * new操作符：用于创建和初始化一个新对象。new关键字后面必须跟一个函数调用，以这种方式使用的函数被称为构造函数（constructor），目的是初始化新对象。

   * 原型：通过对象字面量创建的所有对象都有相同的原型对象，可通过`Object.prototype`引用这个原型对象；使用new关键字和构造函数调用创建的对象，使用构造函数prototype属性的值作为它们的原型。几乎所有对象都有原型，但是只有少数对象有prototype属性，**正是这些有prototype属性的对象为所有其他对象定义了原型**。

     * Object.prtotype是为数不多的没有原型的对象，因为它不继承任何属性。多数内置构造函数和多数用户定义的构造函数的原型都继承自Object.prototype。原型对象；链接起来的序列被称为原型链。

   * Object.create()使用其第一个参数作为新对象的原型。`let a=Object.create({x:1,y:2});`

     * 传入null可以创建一个没有原型的新对象，但这样创建的新对象不会继承任何东西。

     * 若想创建一个普通的空对象(类似{ }或new Object())可传入Object.prototype。

       `let a=Object.create(Object.prototype);`

     * 它还可以接收可选的第二个参数，用于描述新对象的属性。

     * 它的一个用途是防止对象被某个第三方库函数意外（但非恶意）修改。

3. 查询和设置属性

   * 要获取一个属性，可用点(.)或者方括号([ ])操作符。创建或设置属性与查询属性一样，可以使用点或方括号。使用方括号时，其中的表达式必须求值为一个字符串或可以转换为字符串或符号的值。

   * JavaScript对象是关联数组。JavaScript是松散类型语言，即JavaScript程序可以为任意对象创建任意数量的属性。

   * 在使用点操作符访问对象的属性时，属性名是通过标识符来表示的，标识符必须直接书谢在JavaScript程序中，不是一种数据类型，因此不能被程序操作。字符串是动态的，可以在运行时修改；标识符是静态的，必须硬编码到程序中。

     ```
     function addstock(portfolio, stockname, shares){
     	portflolio[stockname]=shares; //这里不能用点操作符
     }
     ```

   * 继承：几乎所有对象都有原型，但大多数对象没有prototype属性，即便不能通过代码直接访问对象的原型，JavaScript继承机制依然照常运行。

   * 属性访问错误：查询不存在的属性不是错误，但查询不存在对象的属性则是错误的，因为null和undefined没有属性。在严格模式下，只要尝试设置属性失败就会抛出TypeError；在非严格模式下，这些失败通常是静默失败。

     * 不可能用同名自有属性隐藏**只读继承属性**。

4. 删除属性

   * 如果delete操作成功或没有影响（如删除不存在的属性），则delete表达式求值为true；对非属性访问表达式（无意义地）使用delete，同时也会求值为true`delete 1;`；delete不会删除configurable特性为false地属性，所以不能删除通过变量声明创建的**全局对象的属性**，尝试删除会导致TypeError。

5. 测试属性

   * 检查对象是否有一个给定名字的属性，可以用in操作符，或者hasOwnProperty()、propertyIsEnumerable()方法，或者直接查询相应的属性。

   * in：`let o={x:1};   "x" in o`

   * hasOwnProperty()：`o.hasOwnProperty("x")`

   * propertyIsEnumerable()细化了hasOwnProperty()测试。需要属性enumerable特性为true才会返回true。

   * 还可用 !==，确保其不是未定义的就可以了。

   * in的特别：可以区分不存在的属性和存在但被设置为undefined的属性。

     ```
     let o={x:undefined};
     o.x!==undefined;	//=>false
     o.y!==undefined;	//=>false
     "x" in o;  //=>true
     "y" in o;  //=>false
     ```

6. 枚举属性

   * 遍历或获取对象的所有属性。
   * 对象继承的内置方法是不可枚举的。
   * 有时可以先获取对象所有属性名的数组，然后再通过for/of循环遍历该数组，有4个函数可用来取得属性名数组。
     * Object.keys()返回对象可枚举自有属性名的数组。不包括不可枚举属性、继承属性或名字是符号的属性。
     * Object.getOwnPropertyNames()，会返回不可枚举自有属性名的数组，只要它们的名字是字符串。
     * Object.getOwnPropertySymbols()，返回名字是符号的自有属性，无论是否可枚举。
     * Reflect.ownKeys()返回所有属性名，包括可枚举和不可枚举属性，以及字符串属性和符号属性。
   * 【ES6】定义了枚举对象自有属性的顺序：
     * 先列出名字为非符整数的字符串，按数值顺序从小到大排列。
     * 剩下的字符串名字的属性按照添加到对象的先后顺序排列。
     * 最后名字为符号的属性再按照添加到对象的先后属性排列。
   * 如果一个对象有两个同名的属性，则后一个属性会把前一个属性覆盖。

7. 扩展对象

   * Object.assign()接收两个或多个对象作为其参数，它修改并**返回第一个参数**。它会把该该对象的可枚举自有属性（包括名字为符号的属性）复制到目标对象。
   * Object.assign()是以普通的属性获取和设置方式复制属性。

8. 序列化对象

   * 对象序列化是把对象的状态转换为字符串的过程，之后可以从中恢复对象的状态。
   * JSON表示JavaScript Object Notation（JavaScript对象表示法），可以序列化和恢复的值包括对象、数组、字符串、有限数值、true、false、null。
   * NaN、Infinity和-Infinity会被序列化为null；日期对象会被序列化为ISO格式的日期字符串（Date.toJSON()函数），但是JSON.parse()不会恢复日期对象；函数、RegExp和Error对象以及undefined不会被序列化或恢复。
   * **JSON.stringify()**序列化对象，只序列化对象的可枚举自有属性。
   * **JSON.parse()**恢复对象
   * 这两个方法都可以接收可选的第二个参数，用于自定义序列化及恢复操作。

9. 对象方法

   * 所有JavaScript对象（除了显示创建为没有原型的）都从Object.prototype继承属性，这些继承的属性主要是方法。以下是Object.prototype上定义的几个通用方法：
   * toString()：不接受参数，返回表示调用它的对象的值的字符串。
     * 默认的tostring()不能提供太多信息，但可用于确定对象的类`let s={x:1}.toString() //=>[object Obeject]`
     * 很多类都会重新定义自己的toString()方法。
   * toLocal**e**String()：返回对象的本地化字符串表示。
     * 默认的toLocaleString()本身没有实现任何本地化，而是简单调用toString()并返回该值。Date和Number类定义了自己的toLocaleString()方法，尝试根据本地惯例**格式化***数值、日期和时间，数组也定义了一个与toString()方法，而不是调用它们的toString()方法。
   * valueOf()：与tostring()很相似，但是会在JavaScript需要**把对象转换为某些非字符串原始值（通常是数值）**时被调用。Date类定义的valueOf()可以将日期转换为数值。
   * toJSON()：Object.prototype()并未定义toJSON()方法，但JSON.stringify()方法会从要序列化的对象上寻找toJSON()方法。如果要序列化的对象存在这个方法，就调用它，然后序列化该方法的返回值，而不是原始对象。
     * Date类定义了自己的toJSON()方法，返回一个表示日期的序列化字符串。

10. 对象字面量扩展语法

    * 简写属性

      * 假设变量x和y中保存着值，而你想创建一个具有属性x和y且值分别为相应变量值的对象。

        ```
        let x=1, y=2;
        let o={x:x,y:y};
        //可改成
        let x=1, y=2;
        let o={x,y};
        ```

    * 计算的属性名（创建需要计算的属性名）

      * ```
        const PROPERTY_NAME="p1";
        function computePropertyName(){return "p"+2;}
        let o={};
        o[PROPERTY_NAME]=1;
        o[computePropertyName()]=2;
        ```

      * 而使用【ES6】称为计算属性的特性可以更简单地创建类似对象。

        ```
        const PROPERTY_NAME="p1";
        function computePropertyName(){return "p"+2;}
        let o={
        [PROPERTY_NAME]:1;
        [computePropertyName()]:2;
        }
        ```

        有了这个语法就可以在方括号中加入任意JavaScript表达式。

    * 符号作为属性名

      * 计算属性语法也让符号作为属性名成为了可能，【ES6】之后，符号可以作为属性名。
      * 创建新符号需要调用Symbol()工厂函数，注意：符号是原始值，不是对象，因此Symbol()不是构造函数，不能用new调用。

    * 扩展操作符

      * 可以把已有对象的属性复制到新对象中。

      * ```
        let position={x:0,y:0};
        let dimensions={width:100,height:75};
        let rect={...position,...dimensions};
        ```

      * 只有在对象字面量中，三个点才会产生这种把一个对象的属性复制到零一个对象中的插值行为。

      * 扩展符号只扩展对象的自有属性，不扩展任何继承属性。

    * 简写方法

      * ```
        let square={
        	area:function(){return this.side;},
        	side=100
        }
        //改成
        let square={
        	area(){return this.side;},
        	side=100
        }
        ```

        此时属性名可以是对象字面量允许的任何形式。

    * 属性的获取方法与设置方法

      * 上述的所有对象属性都是数据属性，除了数据属性，JavaScript还支持为对象定义访问器属性。

      * 这种属性不是一个值，而是一个或两个访问器方法：一个获取方法(getter)和一个设置方法(setter)。

      * 如果一个属性既有获取方法或设置方法，则该属性是一个可读可写属性。

      * ```
        let o={
        dataProp:value,
        get accessorProp(){return this.dataProp;},
        set accessorProp(value){this.dataProp=value;}
        }
        ```

      * 访问器属性可以继承的。

### 7. 数组

1. 前言

   * JavaScript数组是无类型限制的，即数组中的元素可以是任意类型，同一数组的不同元素也可以是不同的类型。

   * JavaScript数组是基于零且使用32位数值索引的。

   * JavaScript数组是动态的，因此创建数组时无须声明一个固定大小，也无须在大小变化时重新为它们分配空间。

   * 创建数组的四种方法：数组字面量、对可迭代对象使用...扩展操作符、Array()构造函数、工厂方法Array.of()和Array.from()

     * 数组字面量：数组字面量中可以是常量、任意表达式、对象字面量或其他数组字面量。注意稀疏数组。

       `let a=[,,,]//长度是2`数组字面量允许末尾出现逗号。

     * 扩展操作符：`let a=[1,2,3]; let b=[...a,4];`，扩展操作符适用于任何可迭代对象。

       * 字符串：`let digits=[..."123abc"]; digits//=>["1","2","3","a","b","c"]`

     * Array()构造函数：三种方式分别是

       * 不传参数`let a=new Array()`；
       * 传入一个参数指定长度`let a=new Array(10)`；
       * 传入多个参数`let a=new Array(5,4,3,2,1)`，则参数为数组元素。

     * Array.of()：是个工厂方法，可以使用其参数值（无论多少个）作为数组元素来创建并返回新数组。

       * `Array.of(10)//=>[10]`
       * Array()无法创建只包含一个数值元素的数组。

     * Array.from()：【ES6】新增的工厂方法，期待一个可迭代对象或类数组对象作为其第一个参数，并返回包含该对象元素的新数组。如果传入可迭代对象，则Array.from(iterable)与使用扩展操作符[...iterable]一样。

       * Array.from()也可以接受第二个参数，如果给第二个参数传入了一个函数，那么在构建新数组时，源对象的每个元素都会传入这个函数，这个函数的返回值将代替原始值成为新数组的元素。

2. 读写数组元素

3. 稀疏数组（反义稠密数组）

   * 稀疏数组就是其元素没有从0开始的索引的数组。

     ```
     let a1=[,];
     let a2=[undefined];
     0 in a1; //=>false
     0 in a2; //=>true
     ```

4. 数组长度

5. 添加和删除数组元素

   * 最简单：`let a=[]; a[0]="zero";`
   * push()方法在数组末尾添加一个或多个元素：`let a=[]; a.push("zero");`，pop()与push()相反。

6.   迭代数组

   * 遍历一个数组（或者任何可迭代对象）的最简单的方式就是使用for/of循环；

   * 如果要对数组使用for/of循环，并且想知道每个数组元素的索引，可以使用数组的entries()方法和解构赋值

   * ```
     let everyother="";
     for(let [index,letter] of letters.entries()){
     	if(index%2==0)everyothers+=letter;
     }
     ```

   * 另一种迭代数组的推荐方式是使用forEach()；数组提供的一种用于自身迭代的函数式方法。需要给forEach()传入一个函数，forEach()会用数组的每个元素调用一次这个函数，能感知稀疏数组

     ```
     let uppercase="";
     letters.forEach(letter=>{
     	uppercase+=letter.toUpperCase();
     });
     ```

7. 多维数组

8. 数组方法

   以上是数组的基本语法，以下是Array类定义的方法

9. 数组迭代器方法

   * forEach()在调用这个函数时会给它传入3个参数：数组元素的值、数组元素的索引和数组本身。

   * map()：把调用它的数组的每个元素分别传给我们指定的函数，返回这个函数的返回值构成的数组。

   * ```
     let a=[1,2,3];
     a.map(x=>x*x);
     ```

   * filter()：传给这个方法的函数应该是一个断言函数，即返回true或false的函数。

   * ```
     let a=[5,4,3,2,1];
     a.filter(x=>x<3); //=>[2,1]
     a.filter((x,i)=>i%2==0); //=>[5,3,1]
     ```

   * find和findIndex()：与filter()类似，但是会在找到第一个元素时停止迭代，find返回元素，findIndex返回索引。没有匹配的时候find返回undefined，findIndex返回-1。

   * every()和some()：是数组的断言方法，最后返回true或false。every对应任意，some对应存在。

   * reduce()和reduceRight()：归并（注入、折叠）；第二个参数是初始值，若没有则数组第一个元素是初始值；传入函数参数是数组值、数组索引、数组。

   * ```
     let a=[1,2,3,4,5];
     a.reduce((x,y)=>x+y,0);
     a.reduce((x,y)=>x*y,1);
     a.reduce((x,y)=>(x>y)?x:y);
     ```

     reduceRight()与reduce()区别在于它是从高索引向低索引处理数组。`a.reduceRight((x,y)=>Math.pow(y,x));`

10. 使用flat()和flatMap()打平数组

    * flat()在不传入参数时只打平一级嵌套。

      ```
      [1,[2,3]].flat(); //=>[1,2,3]
      let a=[1,[2,[3]]];
      a.flat(2);  //=>[1,2,3]
      ```

    * flatMap()与map()类似，但是返回的数组会被自动打平。

11. 使用concat()添加数组

    * 不会打平数组,不改变原数组

    * ```
      let a=[1,2,3];
      a.concat(4,5); //=>[1,2,3,4,5]
      a.concat([4,5],[6,7]); //=>[1,2,3,[4,5],[6,7]]
      a; //=>[1,2,3]
      ```

12. 通过push()、pop()、shift()和unshift()实现栈和队列的操作

    * push、pop在数组末尾，可实现先进后出的栈
    * shift、unshift在数组开头，unshift插入
    * push、shift可实现先进先出的队列
    * 注意：`unshift(1,2) //=>[1,2]`

13. 使用slice()、splice()、fill()和copyWithin()

    * slice()：返回一个数组的切片或者子数组；

      ```
      let a=[1,2,3,4,5];
      a.slice(0,3); //=>[1,2,3]
      a.slice(3); //=>[4,5]
      a.slice(1,-1); //=>[2,3,4]
      ```

    * splice()：对数组进行插入和删除的通用方法，返回被删除的数组。第二个参数是长度。

      ```
      let a=[1,2,3,4,5,6,7,8];
      a.splice(4); //=>[5,6,7,8], a=[1,2,3,4]
      a.splice(1,2); //=>[2,3], a=[1,4]
      a.splice(1,1); //=>[4], a=[1]
      
      let a=[1,2,3,4,5];
      a.splice(2,0,"a","b"); //=>[], a=[1,2,"a","b",3,4,5]
      a.splice(2,2,[1,2],3); //=>["a","b"], a=[1,2,[1,2],3,3,4,5]
      ```

    * fill()：将数组的元素或者切片设置为指定的值。

      ```
      let a=new Array(5);
      a.fill(0); //=>[0,0,0,0,0]
      a.fill(9,1); //=>[0,9,9,9,9]
      a.fill(8,2,-1); //[0,9,8,8,9]
      ```

    * copyWithin()：把数组切片复制到数组中的新位置。

      ```
      let a=[1,2,3,4,5];
      a.copyWithin(1); //=>[1,1,2,3,4]
      a.copyWithin(2,3,5); //=>[1,1,3,4,4]
      a.coptWithin(0,-2); //=>[4,4,3,4,4]
      ```

14. 数组索引和排序方法

    * indexOf()和lastIndexOf()：从数组中搜索指定的值并返回第一个找到的元素的索引，没找到则返回-1，indexOf()从前到后，lastIndexOf()则相反。都接收第二个可选的参数，指定从哪个位置开始搜索。
    * includes()：只接收一个参数，返回true或者false。
    * sort()：对数组元素就地排序并返回排序后的数组。不传参调用时，sort()按字母顺序对数组顺序排序。要对元素执行非字母顺序的排序，必须给sort()传入一个比较函数作为参数。
    * reserve()：反转数组元素的顺序，并返回反序后的数组。

15. 数组到字符串的转换

    * 如果想把数组的文本内容保存起来以备后用，可以使用JSON.stringify()方法对数组执行序列化。

    * join()：把数组的所有元素转换为字符串，然后把它们拼接起来并返回结果字符串。

      ```
      let a=[1,2,3];
      a.join(); //=>"1,2,3"
      a.join(" "); //=>"1 2 3"
      a.join(""); //=>"123"
      ```

      数组也有toString()方法，结果和join()一样

16. 静态数组函数

    Array.of()、Array.from()、Array.isArray()

17. 类数组对象

18. 作为数组的字符串

    * 访问个别字符串：`let s="test"; s.charAt(0); s[1]`
    * 字符串是不可修改的值，因此在把它们当成数组来使用时，它们是只读数组。
### 8.函数



​    

