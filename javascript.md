# 犀牛书学习笔记

[TOC]

## 一、基础知识
> JavaScript简介
> 是Web编程语言，是一门高级、动态、解释型编程语言，适合面向对象和函数式编程风格。语法与Java大致相仿，但除此两者无任何关系。浏览器是其最早的宿主环境，2010年后，出现另一宿主环境Node，可以访问整个操作系统的权限。

### 1. 词法结构（一门语言最低级的语法）
注释：单行// 与 多行/* */
字面量：一种**直接**出现在程序中的数据值。
标识符：即名字，命名常量、变量、属性、函数、类。必须以字母、下划线或美元符号开头。
保留字：不能用作标识符。
Unicode：JavaScript**程序**是用Unicode字符集编写的。故在字符串和注释中可使用任意Unicode字符，建议标识符只用ASCII字母和数字。转义序列（**\u后跟4位十六进制数字**）可令ASCII字符来表示Unicode字符，在注释中会被忽略。注意Unicode归一化。

### 2. 类型、值和变量
* 原始类型： 数值、（文本）字符串、布尔（真）值、**null、undefined**、Symbol（符号）；6
* 对象类型：数组、Set、Map、Date、Error、函数、类等
>任何不是原始类型的值都是对象，对象（对象类型的成员）是属性的集合。对象类型可以修改（mutable），但原始类型不可以修改（immutable），理解字符串不可修改。
>

1. 数值 Number
	* 可用下划线将数值字面量分隔为容易看清的数字段。
	```javascript
	let billion=1_000_000_000;
	let bytes=0x89_AB_CD_EF;
	let bits=0b0001_1101_0111;
	let fraction=0.123_456_789;
	```
	
	* Infinity和NaN：JavaScript预定义了全局常量Infinity和NaN应对正无穷和非数值，可通过Number对象的属性获得。**NaN与任何值比较都不相等**，判断方式：`x!=x`或`Number.isNaN(x)`；负零值与正零值相等（即使在`use strict`下）。
   * 二进制浮点数与舍入错误
	* BigInt：ES2020，定义了一种新的数值类型：BigInt，为表示64位整数，表示：一串数字后面跟‘n’；算术运算不同在于*除法会丢弃余数并向下舍入*；+、-、*、/、**不能混用BigInt操作数和常规数值操作数，比较操作数允许混用，Math对象不接收BigInt操作数。
	
2. 文本 String

   * 字符串是16位值的不可修改的有序序列。
   * 代理对surrogate pair：码点超出16位的Unicode字符使用UTF-16规则编码为两个16位值的序列。
   * 使用反引号定界字符串是【ES6】的特性。
   * 字符串属性：length。
   * JavaScript中的**字符串是不可修改的**，像`replace()`和`toUpperCase()`这样的方法都返回新字符串。
   * 标签化模板字面量
   * 【ES6】提供内置的标签函数`String.raw()`，不会处理任何反斜杠转义。
   * 正则表达式（RegExp）数据类型用于描述和匹配文本中的字符串模式。

3. 布尔值

   * JavaScript的任何值都可以转换为布尔值，转为false：`undefined、null、0、-0、NaN、" "空字符串`，其他所有值都是true。
   * 布尔值只有`toString()`一个方法。

4. null与undefined

   * null通常表示某个值不存在，`typeof null结果是object`。
   * undefined表示变量未初始化、查询不存在的对象属性或数组元素、没有明确返回值的函数返回的值、没有传值的函数参数，它是一个预定义的全局变量。`typeof undefined结果是undefined`。
   * `null==undefined; //true   null===undefined; //false`
   * 他们是**唯一两个没有属性**的值。

5. 符号Symbol

   * 【ES6】新增的一种原始类型，用作非字符串的属性名。
   * 没有字面量语法。
   * `Symbol()`函数获取一个Symbol值，这个函数永远不会返回相同的值，即使每次传入参数一样，保证了唯一性。
   * 全局符号注册表。

6. 全局对象

   * 全局对象的属性是全局性定义的标识符，可以在JavaScript程序的任何地方使用。JavaScript解释器启动后（或每次浏览器加载新页面时），都会创建一个新的全局对象并为其添加一组初始的属性。
   * 在Node中，全局对象有一个名为global的属性。
   * 在浏览器中，**Windows对象对浏览器窗口中的所有JavaScript代码而言，充当了全局对象的角色**。这个全局对象有一个自引用的window属性，可以引用全局对象。
   * **ES2020**最终定义了**`globalThis`**作为在任何上下文中引用全局对象的标准方式。
   
7. 不可修改的原始值与可修改的对象引用

   * 原始类型不可修改，即没有办法改变原始值。
   * 对象有时被称为引用类型（reference type）。

8. 类型转换

   * 转换与相等

   * 显示转换

     * 最简单：`Boolean()、Number()、String()`

     * 除了null和undefined之外，所有值都有`toString()`方法。

     * `Boolean()、Number()、String()`也可以被当作构造函数通过new关键字来使用。

     * 某些JavaScript操作符会执行隐式类型转换。

     * Number类定义 的toString()方法会接收一个可选的参数，用于指定一个基数或底数，默认为10。

     * ```
       let n=123456.789;
       n.toFixed(0) //=>"123457"
       n.toFixed(2) //=>"123456.79"
       n.toExponential(1) //=>"1.2e+5"
       n.toExponential(3) //=>"1.235e+5"
       n.toPrecision(4) //=>"1.235e+5"
       n.toPrecision(7) //=>"123456.8"
       ```

     * `parseInt()`可以接收第二个参数值，用于指定要解析数值的底（基）数；  `parseFloat()`

   * 对象到原始值转换（搭配[对象 — 原始值转换 (javascript.info)](https://zh.javascript.info/object-toprimitive)理解较好）
   
     * JavaScript规范定义了对象到原始值转换的3种基本算法，偏字符串、偏数值、无偏好。
   
     * 算法在JavaScript中的用法：转换为布尔值无需使用上述算法，转换为字符串使用偏字符串，转换为数值用偏数值。
   
     * 存在不遵循上述基本的对象到字符串或数值转换规则的操作符转换特例。
   
     * toString()和valueOf方法：所有对象都会继承的在对象到原始值转换时使用的方法。
   
       ​	toString()返回对象的字符串表示，`({x:1,y:2}).toString() //=>"[object object]"`，很多类都定义了自己特有的toString()版本。
   
       ​	valueOf()方法：大体可认为它把对象转换为代表对象的原始值（若存在这样一个值）；‘对象是复合值，且多数对象不能真正通过一个原始值来表示，因此默认情况下**只返回对象本身，而非返回原始值**。
       
       | 算法         | 顺序                                                         |
       | ------------ | ------------------------------------------------------------ |
       | 偏字符串算法 | 先toString()再valueOf()                                      |
       | 偏数值算法   | 先valueOf()再toString()                                      |
       | 无偏好算法   | 取决被转换对象的类，若为Date则用偏字符串算法，其他用偏数值算法 |
   
9. 变量声明与赋值

   * 使用let和const声明
      * 【ES6】之后是通过let关键字声明的；若不为变量指定初始值，则默认undefined。
      * const必须在声明时初始化常量，常量的值是不能改变的，尝试给常量重新赋值会抛出**TypeError**；声明常量的一个常见约定是全部字母大写。
      * let和const声明的变量和常量具有块作用域。
      * JavaScript的**变量声明与值的类型无关**。
      
   * 使用var的变量声明
     * 【ES6】之前的JavaScript中，声明变量的唯一方式是使用var，无法声明常量。
     * 与let不同：
       * (1) 不具有块作用域，var的作用域是函数作用域。
       * (2) 若在函数体外部使用var，则会声明一个全局变量，并且实现为全局对象的属性。
       * (3) 多次声明是合法的。
       * (4) var有作用域提升的特性，即在var语句声明之前可以使用该变量。
     
   * 解构赋值【ES6】（destructuring assignment）
      * 数组结构
      
        * 解构让使用返回数组的函数变得敏捷；
      
        * 解构左侧变量的个数不一定与右侧数组中元素的个数相同，左侧多余的变量会被设为undefined，右侧多余的会被忽略，左侧的变量列表可以包含额外的逗号来跳过右侧的某些值。
      
          ```
          let [x,y]=[1]; //x==1; y==undefined
          [,x,,y]=[1,2,3,4]; //x==2; y==4
          ```
      
        * `let[x,...y]=[1,2,3,4]; //y=[2,3,4]`
      
        * 可以嵌套数组：`let [a,[b,c]]=[1,[2,2.5],3]; //a==1; b=2; c=2.5`
      
      * 对象结构
      
        * ````
          let transparent={r:0.0; g:0.0; b:0.0, a:1.0};
          let {r,g,b}=transparent; //r==0.0; g==0.0; b==0.0
          ````
      
        * 例子：将Math对象的全局函数复制到变量中，可简化需要大量三角计算的代码
      
          `const {sin,cos,tan}=Math;`**Math对象的属性远不止这3个，如果赋值左侧包含一个不是Math属性的变量名，该变量将被赋值undefined。**`const {cos:cosine,tan:tangent}=Math;`
      
      * 数组结构并**不要求必须是数组**，任何可迭代对象、任何可以在for/of循环中使用的对象也可以被解构
      
        `let [first,...rest]="Hello"; //first="H"; rest=["e","l","1","o"]`

### 3. 表达式和操作符（表达式是JavaScript程序中的短语）

1. 主表达式
   * 最简单的表达式称为主表达式，包括常量或字面量值、某些语言关键字和变量引用。
   * 当程序中出现任何独立的标识符时，JavaScript假设它时一个变量或常量或全局对象的属性，并查询它的值。如果不存在该名字的变量，则求值不存在的变量会导致抛出`ReferenceError`。
   
2. 对象和数组的初始化程序
   * 对象和数组初始化程序也是一种表达式，其值为新创建的对象或数组，有时被称为对象字面量和数组字面量。
   * `let sparseArray=[1,,,,5]`
   * 对象初始化程序表达式：`let p={x:1, y:2}`
   * 【ES6】后，对象字面量拥有更丰富的语法，可以嵌套。
   
3. 函数定义表达式
   * `let square=function(x){return x*x;};`记得最后有一个分号。
   
4. 属性访问表达式

   * 属性访问表达式求值为对象属性或数组元素的值，两种语法：`expression.identifier; expression[identifier]`

     第一种语法只用于**对象**。

5. 条件式属性访问

   * 【ES2020】新增两个新的属性访问表达式：`expression?.identifier; expression?.[expression]`，避免**如果.或[]左侧的表达式求值为null或undefined会报TypeError**的错误。
   * `a?.b`若a是null或者undefined则求值结果为undefined。
   * 这种形式有时也被称为“可选链接”。
   * 短路操作。

6. 调用表达式

   * 调用表达式是JavaScript中调用（或执行）函数或方法的一种语法。例子：

     ```
     f(0)
     Math.max(x,y,z)
     a.sort()
     ```

   * 求值调用表达式时，首先求值函数表达式，然后求值参数表达式以产生参数值的列表。

   * 如果函数使用了return语句返回一个值，则该值就成为调用表达式的值；否则值为undefined。

   * 如果该表达式是**属性访问表达式**，则这种调用被称为方法调用。在方法调用中，作为属性访问主体的对象或数组在执行函数体时会变成this关键字的值。

7. 条件式调用（联系条件式属性访问）

   * 【ES2020】中，可以使用`?.()`来调用函数，处理的问题跟条件式属性访问类似。

   * 短路操作：`let f=null,x=0;  f?.(x++) //x不会自增`

   * 区分一下：

     ```
     o.m()		//常规属性访问，常规调用
     o?.m()		//条件式属性访问，常规调用
     o.m?.()		//常规属性访问，条件式调用
     ```

8. 对象创建表达式

   * 对象创建表达式创建一个新对象并调用一个函数（称为构造函数）来初始化这个新对象。
   * `new Object(); new Point(2,3)`
   * 如果在对象创建表达式中不会给构造函数传参，则可以省略圆括号。`new Object; new Date`
   * 对象创造表达式的值时新创建的对象。

9. 操作符概述

   * 操作符用于算术表达式、比较表达式、逻辑表达式、赋值表达式等。

   * | 操作符 | 操作                     | 结合性 | 操作数个数 | 类型转换     |
     | ------ | ------------------------ | ------ | ---------- | ------------ |
     | ~      | 反转二进制位             | 右     | 1          | int~int      |
     | delete | 删除**属性**             | 右     | 1          | lval~bool    |
     | void   | 返回undefined            | 右     | 1          | any~undef    |
     | <<     | 左移位                   | 左     | 2          | int,int~int  |
     | >>     | 右移位以符号填充         | 左     | 2          | int,int~int  |
     | >>>    | 右移位以零填充           | 左     | 2          | int,int~int  |
     | in     | 测试**属性**是否存在     | 左     | 2          | any,obj~bool |
     | ??     | 选择第一个有定义的操作数 | 左     | 2          | any,any~any  |
     | ,      | 丢弃第一个，返回第二个   | 左     | 2          | any,any~any  |
	  
	* 注意有些操作符适用于任何类型的值，但多数操作符期待自己的操作数是某种特定类型。
	
	* JavaScript操作符通常会按照需要转换操作数的类型，`"3"*"5"`合法。
	
	* **lval**即lvalue（左值），历史悠久的术语，意思是“一个可以合法地出现在赋值表达式左侧的表达式”，在JavaScript中，**变量、对象属性和数组元素**都是“左值”。
	
	* 操作符副效应：有副效应的操作符—赋值操作符，递增和递减操作符，delete。
	
	* 操作符优先级：属性访问和调用表达式的优先级高于表4-1中列出的任何操作符。注意：`??  **`
	
	* JavaScript始终严格按照从左到右的顺序对表达式求值。
	
10. 算术表达式

    * 在JavaScript中，所有数值都是浮点数，因此所有除法操作数得到的都是浮点数。模操作数通常用于整数，但也可以用于浮点数。

    * +操作符

      ```
      1+2 //=>3
      "1"+"2" //=>"12"
      "1"+2 //=>"12"
      1+{} //=>"1[object Object]"
      true+true //=>2
      2+null //=>2
      2+undefined //=>NaN
      ```

    * 一元算术操作符

      * 一元操作符全部具有高优先级和右结合性。

    * 位操作符

11. 关系表达式

    * 关系表达式始终求值为布尔值，经常用于控制程序的执行流。

    * 对象是按引用而不是按值比较的，对象与自己相等，但与其他任何对象都不相等。

    * ===：如果一个或两个值是NaN，则不相等**（NaN不等于自身）**，检查某值是不是本身`x!==x或isNaN()`

    * ==：基于类型转换的相等。`null==undefined //=>true`

    * 比较操作符的操作数可能是任何类型，但比较只能针对数值和字符串，因此不是数值或字符串的操作数**会被转换类型**。如果转换或两个操作数都是字符串，则用字母表顺序比较（即组成字符串的**16位Unicode的数值顺序**）；若转换后至少一个不是字符串，则都被转换成数值来比较。

    * 如果有一个操作数是（或转换后是）NaN，那么这些比较操作符都返回false。

    * 更可靠的字符串比较算法可用String.localeCompare()方法，会考虑特定地区的字母表顺序。要执行不区分大小写的比较，可以使用String.toLowerCase()或String.toUpperCase()先转换成大写或小写再比较。

    * 比较操作符偏向于数值，+偏向于字符串。

    * in操作符：左侧操作数是**字符串、符号**或可以转换成字符串的值，右侧是**对象**；若左侧的值是右侧对象的属性名，则in返回true。

    * instanceof 操作符：左侧是**对象**，右侧是对象类的标识，返回true或false。

      `let d=new Date(); d instanceof Date`

      所有对象都是Object的实例，在确定对象是不是某个类的实例时会考虑超类，若左侧不是对象，则返回false，若右侧不是对象的类则抛出TypeError。理解其工作方式需要理解“原型链”。

12. 逻辑表达式

    * &&：有代码利用**这种行为**条件式地执行代码。`if(a===b)stop();与(a===b)&&stop();效果一样`
    * ||：习惯用法是在一系列备选项中选择第一个真值。`let max=maxWidth||preferences.maxWidth||500`，在【ES6】之前常用来在函数中给参数提供默认值，但【ES6】之后默认参数可以直接写在函数定义中。
    * !：要取得任何值x对应地布尔值，只要对x应用这个操作符两次即可。`!!x`

13. 赋值表达式

    * =具有右结合性。`i=j=k=0;`

14. 求值表达式

    * 全局函数eval()：JavaScript通过这个函数来对源代码字符串求值，`eval("3+2") //=>5`
    * 对源代码字符串的动态求值是一个强大的语言特性，但这种特性在实际项目中几乎用不到。eval()可能会成为安全漏洞，为此永远不要把来自用户输入的字符串交给它执行。
    * eval()期待一个参数，如果给它传入任何非字符串值，它会简单地返回这个值；如果传入字符串，他会尝试把这个字符串当成JavaScript代码来解析，解析失败会抛出SyntaxError；解析成功会求值代码并返回该字符串中最后一个表达式或语句的值；若最后一个表达式或语句没有值，则返回undefined。
    * use strict下的eval()

15. 其他操作符

    * ?:

    * ??：**先定义操作符**，只要左操作数不是null或undefined就返回左操作数。与||比较，可以处理0、空字符串、flase；??是在【ES2020】定义的，这个操作符的正式名字叫“缺值合并”（nullish coalescing）操作符。

    * typeof操作符：

      | x        | undefined   | null     | true/false | 数值或NaN | BigInt   | 字符串   | 符号     | 函数       | 非函数对象 |
      | -------- | ----------- | -------- | ---------- | --------- | -------- | -------- | -------- | ---------- | ---------- |
      | typeof x | "undefined" | "object" | "boolean"  | "number"  | "bigint" | "string" | "symbol" | "function" | "object"   |

    * delete操作符：尝试删除其操作数指定的对象属性或数组元素，并设置为undefined。

      * 注意：删除数组元素之后，数组长度没有变化；
      * 并非所有属性都是可以删除的：不可配置属性无法删除；
      * 在严格模式下，delete的操作数如果是未限定标识符，如变量、函数、函数参数，则会导致SyntaxError；严格模式下只能用作属性访问表达式。严格模式外不会发生异常，只是简单地返回false。

    * await操作符：【ES2017】增加的，用于让JavaScript中的异步编程更自然；await期待一个Promise对象作为唯一操作数，await只能出现在已经通过async关键字声明为异步的函数中。

    * void操作符：一元操作符，出现在操作数前面，操作数可以是任意类型。用处不多：求值自己的操作数，然后丢弃这个值并返回undefined。

    * 逗号操作符：会求值其左操作数，求值其右操作数，然后返回右操作数的值。

### 4.语句

1. 表达式语句：有副效应的表达式。

2. 复合语句与空语句：语句块将多个语句组合为一个复合语句。

3. 条件语句：是 代码中需要决策的地方，故也被称为“分支”。规则：默认情况下else子句属于最近的if语句。

   ```
   switch(n){
   case 1: 
   	break;
   case 2:
   	break;
   default:
   	break;
   }
   ```

4. 循环语句：

   * 常见用途：迭代数组元素。

   * do循环必须始终以分号终止。

   * for/of：【ES6】定义的新循环语句，专门用于可迭代对象，如数组、字符串、集合、映射，对象是不可迭代的。

     ```
     let data=[1,2,3,4,5],sum=0;
     for(let element of data){
     	sum+=element;
     }
     ```

     尝试对常规对象使用for/of会抛出TypeError，若想迭代对象的属性，可以使用for/in循环，或者基于Object.keys()方法的结果使用for/of：`for (let k of Obeject.keys(object)){}`，因为Object.keys()返回一个**对象属性名**的数组。还有Object.entries()方法，返回一个数组的数组，每个内部数组表示对象的一个属性的键/值对。

     注意：字符串是按照Unicode码点而不是UTF-16迭代的。

   * for/in：后面可以是任意**对象**，是JavaScript从一开始就有的。`for(variable in object)statement`，variable通常是一个变量名，但也可能是变量声明或任何可以作为赋值表达式左值的东西。variable可能是任何表达式，只要能求值为赋值表达式的左值就可以。如，把一个对象的所有属性赋值到数组中：

     ```
     let o={x:1,y:2,z:3};
     let a=[],i=0;
     for(a[i++] in 0); //空循环体
     ```

     JavaScript数组其实就是一种特殊的对象，数组的索引就是对象的属性，所以可以通过for/in来枚举。但是**操作数组时，基本上只会用到for/of而不是for/in**。

     for/in不会枚举对象的所有属性，如不会枚举名字为符号的属性，对于名字是字符串的属性，只会遍历枚举的属性，JavaScript核心定义的各种**内部方法**是不可枚举的。基于Object.keys()使用for/of循环可避免这问题。

5. 跳转语句

   * JavaScript允许给语句命名或加标签，这样break和continue就可以识别目标循环或其他语句的标签。

   * 语句标签：`identifier:statement`，任何语句都可以有标签，但是只有给那些有语句体的语句加标签才有意义。break和continue是JavaScript中唯一使用语句标签的语句。

   * break只有位于循环或switch语句中才合法，break与labelname之间不能出现换行符。

   * continue只能在循环体内使用，continue与labelname之间不能出现换行符。

   * return只能出现在函数体内，不能在return和它后面的表达式之间插入换行。

   * yield语句非常类似return，但只能用在【ES6】新增的生成器函数中，以回送生成的值序列中的下一个值，同时又不会真正返回。

   * throw语句，Error类只有一个name属性和一个message属性，分别用于指定错误类型和保存传入构造函数的字符串。

   * ```
     //模拟for(initiallize;test;increment)循环体
     initialize;
     while(test){
     try{body;}
     finally{increment;}
     }
     ```

   * with语句：`with(object) statement`，创建一个临时作用域，以object的属性作为变量，然后在这个作用域中执行statement，尽可能不使用它，严格模式下是被禁用的，非严格模式下也是被废弃了的。使用它主要是为了更方便地使用深度嵌套的对象。

     ```
     with(document.forms[0]){
     	name.value="";
     	address.value="";
     	email.value="";
     }
     ```

   * debugger语句：这个语句就像一个断点，执行中的JavaScript会停止。注意：debugger语句并不为你打开调试器。只有你使用浏览器并且打开了开发者控制台，这个语句才会导致断点。

   * `use strict`是【ES5】引入的一个指令，它与常规语句有两个重要区别：(1)指令是由（包含在单引号或双引号中的）特殊字符串字面量构成的表达式语句。(2)只能出现在脚本或函数体的开头，位于其他真正的语句之前。任何位于class体或P【ES6】模块中的代码全部默认为严格代码，无需显式写出"use strict"。

     * 严格模式是JavaScript的一个受限制的子集，这个子集修复了重要的语言缺陷，提供了更强的错误检查，也增强了安全性。

   * 

6. 
